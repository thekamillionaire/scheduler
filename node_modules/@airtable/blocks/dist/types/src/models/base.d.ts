/** @module @airtable/blocks/models: Base */ /** */
import { BaseData } from '../types/base';
import { CollaboratorData, UserId } from '../types/collaborator';
import { FieldType } from '../types/field';
import { PermissionCheckResult } from '../types/mutations';
import { TableId } from '../types/table';
import { ObjectValues } from '../private_utils';
import Table from './table';
import AbstractModel from './abstract_model';
declare const WatchableBaseKeys: Readonly<{
    name: "name";
    tables: "tables";
    collaborators: "collaborators";
    schema: "schema";
}>;
/**
 * Any key in base that can be watched:
 * - `name`: the name of the base
 * - `tables`: the order of tables in the base
 * - `collaborators`: all the collaborators in the base
 * - `schema`: the base schema (essentially everything except for record data)
 */
declare type WatchableBaseKey = ObjectValues<typeof WatchableBaseKeys>;
/**
 * Model class representing a base.
 *
 * If you want the base model to automatically recalculate whenever the base schema changes, try the
 * {@link useBase} hook. Alternatively, you can manually subscribe to changes with
 * {@link useWatchable} (recommended) or [Base#watch](/api/models/Base#watch).
 *
 * @example
 * ```js
 * import {base} from '@airtable/blocks';
 *
 * console.log('The name of your base is', base.name);
 * ```
 * @docsPath models/Base
 */
declare class Base extends AbstractModel<BaseData, WatchableBaseKey> {
    /**
     * The name of the base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log('The name of your base is', base.name);
     * ```
     */
    get name(): string;
    /**
     * The tables in this base. Can be watched to know when tables are created, deleted, or reordered in the base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log(`You have ${base.tables.length} tables`);
     * ```
     */
    get tables(): Array<Table>;
    /**
     * The users who have access to this base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log(base.activeCollaborators[0].email);
     * ```
     */
    get activeCollaborators(): Array<CollaboratorData>;
    /**
     * The user matching the given ID, or `null` if that user does not exist or does not have access
     * to this base.
     *
     * @param collaboratorId The ID of the user.
     */
    getCollaboratorByIdIfExists(collaboratorId: UserId): CollaboratorData | null;
    /**
     * The user matching the given ID. Throws if that user does not exist
     * or does not have access to this base. Use {@link getCollaboratorByIdIfExists}
     * instead if you are unsure whether a collaborator with the given ID exists
     * and has access to this base.
     *
     * @param collaboratorId The ID of the user.
     */
    getCollaboratorById(collaboratorId: UserId): CollaboratorData;
    /**
     * The user matching the given ID, name, or email address. Returns null if that user does not
     * exist or does not have access to this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getCollaboratorByIdIfExists} method instead.
     *
     * @param collaboratorIdOrNameOrEmail The ID of the user.
     */
    getCollaboratorIfExists(idOrNameOrEmail: UserId | string): CollaboratorData | null;
    /**
     * The user matching the given ID, name, or email address. Throws if that user does not exist
     * or does not have access to this base. Use {@link getCollaboratorIfExists} instead if you are
     * unsure whether a collaborator with the given ID exists and has access to this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getCollaboratorById} method instead.
     *
     * @param collaboratorIdOrNameOrEmail The ID of the user.
     */
    getCollaborator(idOrNameOrEmail: UserId | string): CollaboratorData | null;
    /**
     * The table matching the given ID, or `null` if that table does not exist in this base.
     *
     * @param tableId The ID of the table.
     */
    getTableByIdIfExists(tableId: string): Table | null;
    /**
     * The table matching the given ID. Throws if that table does not exist in this base. Use
     * {@link getTableByIdIfExists} instead if you are unsure whether a table exists with the given
     * ID.
     *
     * @param tableId The ID of the table.
     */
    getTableById(tableId: string): Table;
    /**
     * The table matching the given name, or `null` if no table exists with that name in this base.
     *
     * @param tableName The name of the table you're looking for.
     */
    getTableByNameIfExists(tableName: string): Table | null;
    /**
     * The table matching the given name. Throws if no table exists with that name in this base. Use
     * {@link getTableByNameIfExists} instead if you are unsure whether a table exists with the
     * given name.
     *
     * @param tableName The name of the table you're looking for.
     */
    getTableByName(tableName: string): Table;
    /**
     * The table matching the given ID or name. Returns `null` if no matching table exists within
     * this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getTableByIdIfExists} or
     * {@link getTableByNameIfExists} methods instead.
     *
     * @param tableIdOrName The ID or name of the table you're looking for.
     */
    getTableIfExists(tableIdOrName: TableId | string): Table | null;
    /**
     * The table matching the given ID or name. Throws if no matching table exists within this base.
     * Use {@link getTableIfExists} instead if you are unsure whether a table exists with the given
     * name/ID.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getTableById} or {@link getTableByName} methods
     * instead.
     *
     * @param tableIdOrName The ID or name of the table you're looking for.
     */
    getTable(tableIdOrName: TableId | string): Table;
    /**
     * _Beta feature with unstable API. May have breaking changes before release._
     *
     * Checks whether the current user has permission to create a table.
     *
     * Accepts partial input, in the same format as {@link unstable_createTableAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param name name for the table. must be case-insensitive unique
     * @param fields array of fields to create in the table
     *
     * @example
     * ```js
     * const createTableCheckResult = base.unstable_checkPermissionsForCreateTable();
     *
     * if (!createTableCheckResult.hasPermission) {
     *     alert(createTableCheckResult.reasonDisplayString);
     * }
     * ```
     */
    unstable_checkPermissionsForCreateTable(name?: string, fields?: Array<{
        name?: string;
        type?: FieldType;
        options?: {
            [key: string]: unknown;
        } | null;
    }>): PermissionCheckResult;
    /**
     * _Beta feature with unstable API. May have breaking changes before release._
     *
     * An alias for `checkPermissionsForCreateTable(name, fields).hasPermission`.
     *
     * Checks whether the current user has permission to create a table.
     *
     * Accepts partial input, in the same format as {@link unstable_createTableAsync}.
     *
     * @param name name for the table. must be case-insensitive unique
     * @param fields array of fields to create in the table
     *
     * @example
     * ```js
     * const canCreateTable = table.unstable_hasPermissionToCreateTable();
     *
     * if (!canCreateTable) {
     *     alert('not allowed!');
     * }
     * ```
     */
    unstable_hasPermissionToCreateTable(name?: string, fields?: Array<{
        name?: string;
        type?: FieldType;
        options?: {
            [key: string]: unknown;
        } | null;
    }>): boolean;
    /**
     * _Beta feature with unstable API. May have breaking changes before release._
     *
     * Creates a new table.
     *
     * Throws an error if the user does not have permission to create a table, if an invalid
     * table name is provided, or if invalid fields are provided (invalid name, type or options).
     *
     * Refer to {@link FieldType} for supported field types, the write format for field options, and
     * other specifics for certain field types.
     *
     * At least one field must be specified. The first field in the `fields` array will be used as
     * the table's [primary field](https://support.airtable.com/hc/en-us/articles/202624179-The-Name-Field)
     * and must be a supported primary field type. Fields must have case-insensitive unique names
     * within the table.
     *
     * A default grid view will be created with all fields visible.
     *
     * This action is asynchronous. Unlike new records, new tables are **not** created
     * optimistically locally. You must `await` the returned promise before using the new
     * table in your block.
     *
     * @param name name for the table. must be case-insensitive unique
     * @param fields array of fields to create in the table: see below for details.
     *
     * @example
     * ```js
     * async function createNewTable() {
     *     const name = 'My new table';
     *     const fields = [
     *         // Name will be the primary field of the table.
     *         {name: 'Name', type: FieldType.SINGLE_LINE_TEXT},
     *         {name: 'Notes', type: FieldType.RICH_TEXT},
     *         {name: 'Attachments', type: FieldType.MULTIPLE_ATTACHMENTS},
     *         {name: 'Number', type: FieldType.NUMBER, options: {
     *             precision: 8,
     *         }},
     *         {name: 'Select', type: FieldType.SINGLE_SELECT, options: {
     *             choices: [
     *                 {name: 'A'},
     *                 {name: 'B'},
     *             ],
     *         }},
     *     ];
     *
     *     if (base.unstable_hasPermissionToCreateTable(name, fields)) {
     *         await base.unstable_createTableAsync(name, fields);
     *     }
     * }
     * ```
     */
    unstable_createTableAsync(name: string, fields: Array<{
        name: string;
        type: FieldType;
        options?: {
            [key: string]: unknown;
        } | null;
    }>): Promise<Table>;
}
export default Base;
//# sourceMappingURL=base.d.ts.map