"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/es.string.starts-with");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _get2 = _interopRequireDefault(require("@babel/runtime/helpers/get"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _colors = _interopRequireDefault(require("../colors"));

var _field = require("../types/field");

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _abstract_model_with_async_data = _interopRequireDefault(require("./abstract_model_with_async_data"));

var _field2 = _interopRequireDefault(require("./field"));

var _record_coloring = require("./record_coloring");

/** @module @airtable/blocks/models: RecordQueryResult */

/** */
var WatchableRecordQueryResultKeys = Object.freeze({
  records: 'records',
  recordIds: 'recordIds',
  cellValues: 'cellValues',
  recordColors: 'recordColors',
  isDataLoaded: 'isDataLoaded'
});
var WatchableCellValuesInFieldKeyPrefix = 'cellValuesInField:'; // The string case is to accommodate cellValuesInField:$FieldId.

/**
 * A key in {@link RecordQueryResult} that can be watched
 * - `records`
 * - `recordIds`
 * - `cellValues`
 * - `recordColors`
 * - `isDataLoaded`
 * - `cellValuesInField:{FIELD_ID}`
 */

/**
 * A RecordQueryResult represents a set of records. It's a little bit like a one-off View in Airtable: it
 * contains a bunch of records, filtered to a useful subset of the records in the table. Those
 * records can be sorted according to your specification, and they can be colored by a select field
 * or using the color from a view. Just like a view, you can either have all the fields in a table
 * available, or you can just ask for the fields that are relevant to you. There are two types of
 * QueryResult:
 *
 * - {@link TableOrViewQueryResult} is the most common, and is a query result filtered to all the
 *   records in a specific {@link Table} or {@link View}. You can get one of these with
 *   `table.selectRecords()` or `view.selectRecords()`.
 * - {@link LinkedRecordsQueryResult} is a query result of all the records in a particular
 *   [linked record cell](https://support.airtable.com/hc/en-us/articles/206452848-Linked-record-fields).
 *   You can get one of these with `record.selectLinkedRecordsFromCell(someField)`.
 *
 * Once you've got a query result, you need to load it before you can start working with it -
 * blocks don't load record data by default. We recommend using {@link useRecords},
 * {@link useRecordIds}, {@link useRecordById} or {@link useLoadable} to handle this.
 *
 * If you're not using a query result in a React component, you can manually load the data and
 * unload it when you're finished:
 *
 * ```js
 * async function fetchRecordsAndDoSomethingAsync(myTable) {
 *     // query for all the records in "myTable"
 *     const queryResult = myTable.selectRecords();
 *
 *     // load the data in the query result:
 *     await queryResult.loadDataAsync();
 *
 *     // work with the data in the query result
 *     doSomething(queryResult);
 *
 *     // when you're done, unload the data:
 *     queryResult.unloadData();
 * }
 * ```
 *
 * Whilst loaded, a query result will automatically keep up to date with what's in Airtable:
 * records will get added or removed, the order will change, cell values will be updated, etc.
 * Again, if you're writing a React component then our hooks will look after that for you. If not,
 * you can get notified of these changes with `.watch()`.
 *
 * When calling a `.select*` method, you can pass in a number of options to control the sort order,
 * fields loaded and coloring mode of records: see {@link RecordQueryResultOpts} for examples.
 *
 * @docsPath models/query results/RecordQueryResult
 */
var RecordQueryResult =
/*#__PURE__*/
function (_AbstractModelWithAsy) {
  (0, _inherits2.default)(RecordQueryResult, _AbstractModelWithAsy);
  (0, _createClass2.default)(RecordQueryResult, [{
    key: "_getOrGenerateRecordIdsSet",

    /**
     * The set of record IDs in this QueryResult.
     * Throws if data is not loaded yet.
     *
     * @internal
     */
    value: function _getOrGenerateRecordIdsSet() {
      throw (0, _error_utils.spawnAbstractMethodError)();
    }
    /**
     * The fields that were used to create this QueryResult.
     * Null if fields were not specified, which means the QueryResult
     * will load all fields in the table.
     */

  }, {
    key: "recordIds",
    // Abstract properties - classes extending QueryResult must override these:

    /** @internal */

    /**
     * The record IDs in this QueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     */
    get: function get() {
      throw (0, _error_utils.spawnAbstractMethodError)();
    }
  }, {
    key: "fields",
    get: function get() {
      throw (0, _error_utils.spawnAbstractMethodError)();
    }
    /**
     * @internal (since we may not be able to return parent model instances in the immutable models world)
     * The table that records in this QueryResult are part of
     */

  }, {
    key: "parentTable",
    get: function get() {
      throw (0, _error_utils.spawnAbstractMethodError)();
    } // provided properties + methods:

    /** @internal */

  }], [{
    key: "_isWatchableKey",

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableRecordQueryResultKeys, key) || key.startsWith(WatchableCellValuesInFieldKeyPrefix);
    }
    /** @internal */

  }, {
    key: "_shouldLoadDataForKey",
    value: function _shouldLoadDataForKey(key) {
      return key === RecordQueryResult.WatchableKeys.records || key === RecordQueryResult.WatchableKeys.recordIds || key === RecordQueryResult.WatchableKeys.cellValues || key === RecordQueryResult.WatchableKeys.recordColors || key.startsWith(RecordQueryResult.WatchableCellValuesInFieldKeyPrefix);
    }
    /** @internal */

  }, {
    key: "_normalizeOpts",
    value: function _normalizeOpts(table, recordStore) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var sorts = !opts.sorts ? null : opts.sorts.map(sort => {
        var field = table.__getFieldMatching(sort.field);

        if (sort.direction !== undefined && sort.direction !== 'asc' && sort.direction !== 'desc') {
          throw (0, _error_utils.spawnError)('Invalid sort direction: %s', sort.direction);
        }

        return {
          fieldId: field.id,
          direction: sort.direction || 'asc'
        };
      });
      var fieldIdsOrNullIfAllFields = null;

      if (opts.fields) {
        (0, _error_utils.invariant)(Array.isArray(opts.fields), 'Must specify an array of fields');
        fieldIdsOrNullIfAllFields = [];
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = opts.fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var fieldOrFieldIdOrFieldName = _step.value;

            if (!fieldOrFieldIdOrFieldName) {
              // Filter out false-y values so users of this API
              // can conveniently list conditional fields, e.g. [field1, isFoo && field2]
              continue;
            }

            if (typeof fieldOrFieldIdOrFieldName !== 'string' && !(fieldOrFieldIdOrFieldName instanceof _field2.default)) {
              throw (0, _error_utils.spawnError)('Invalid value for field, expected a field, id, or name but got: %s', fieldOrFieldIdOrFieldName);
            }

            var field = table.__getFieldMatching(fieldOrFieldIdOrFieldName);

            fieldIdsOrNullIfAllFields.push(field.id);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      var recordColorMode = opts.recordColorMode || _record_coloring.modes.none();

      switch (recordColorMode.type) {
        case _record_coloring.ModeTypes.NONE:
          break;

        case _record_coloring.ModeTypes.BY_SELECT_FIELD:
          (0, _error_utils.invariant)(recordColorMode.selectField.type === _field.FieldType.SINGLE_SELECT, 'Invalid field for coloring records by select field: expected a %s, but got a %s', _field.FieldType.SINGLE_SELECT, recordColorMode.selectField.type);
          (0, _error_utils.invariant)(recordColorMode.selectField.parentTable === table, 'Invalid field for coloring records by select field: the single select field is not in the same table as the records');

          if (fieldIdsOrNullIfAllFields) {
            fieldIdsOrNullIfAllFields.push(recordColorMode.selectField.id);
          }

          break;

        case _record_coloring.ModeTypes.BY_VIEW:
          (0, _error_utils.invariant)(recordColorMode.view.parentTable === table, 'Invalid view for coloring records from view: the view is not in the same table as the records');
          break;

        default:
          throw (0, _error_utils.spawnError)('Unknown record coloring mode: %s', (0, _private_utils.cast)(recordColorMode));
      }

      (0, _error_utils.invariant)(table.id === recordStore.tableId, 'record store and table must match');
      return {
        sorts,
        fieldIdsOrNullIfAllFields,
        recordColorMode,
        table,
        recordStore
      };
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function RecordQueryResult(normalizedOpts, baseData) {
    var _this;

    (0, _classCallCheck2.default)(this, RecordQueryResult);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RecordQueryResult).call(this, baseData, (0, _private_utils.getLocallyUniqueId)('RecordQueryResult')));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_normalizedOpts", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_recordStore", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_recordColorChangeHandler", null);
    _this._normalizedOpts = normalizedOpts;
    _this._recordStore = normalizedOpts.recordStore;
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(RecordQueryResult, [{
    key: "__canBeReusedForNormalizedOpts",
    value: function __canBeReusedForNormalizedOpts(normalizedOpts) {
      return (0, _private_utils.isDeepEqual)(this._normalizedOpts, normalizedOpts);
    }
    /**
     * The records in this RecordQueryResult.
     * Throws if data is not loaded yet.
     * Can be watched.
     */

  }, {
    key: "getRecordByIdIfExists",

    /**
     * Get a specific record in the query result, or null if that record doesn't exist or is
     * filtered out. Throws if data is not loaded yet. Watch using `'recordIds'`.
     *
     * @param recordId the ID of the {@link Record} you want
     */
    value: function getRecordByIdIfExists(recordId) {
      var record = this._recordStore.getRecordByIdIfExists(recordId);

      if (!record || !this.hasRecord(record)) {
        return null;
      }

      return record;
    }
    /**
     * Get a specific record in the query result, or throws if that record doesn't exist or is
     * filtered out. Throws if data is not loaded yet. Watch using `'recordIds'`.
     *
     * @param recordId the ID of the {@link Record} you want
     */

  }, {
    key: "getRecordById",
    value: function getRecordById(recordId) {
      var record = this.getRecordByIdIfExists(recordId);

      if (!record) {
        throw (0, _error_utils.spawnError)('No record with ID %s in this query result', recordId);
      }

      return record;
    }
    /**
     * @internal
     */

  }, {
    key: "_getRecord",
    value: function _getRecord(recordOrRecordId) {
      return this.getRecordById(typeof recordOrRecordId === 'string' ? recordOrRecordId : recordOrRecordId.id);
    }
    /**
     * Check to see if a particular record or record id is present in this query result. Returns
     * false if the record has been deleted or is filtered out.
     *
     * @param recordOrRecordId the record or record id to check the presence of
     */

  }, {
    key: "hasRecord",
    value: function hasRecord(recordOrRecordId) {
      var recordId = typeof recordOrRecordId === 'string' ? recordOrRecordId : recordOrRecordId.id;
      return this._getOrGenerateRecordIdsSet()[recordId] === true;
    }
    /**
     * Get the {@link Color} of a specific record in the query result. Returns null if the record
     * has no color in this query result. Throws if the record isn't in the RecordQueryResult. Watch
     * with the `'recordColors'` and `'recordIds` keys.
     *
     * @param recordOrRecordId the record or record ID you want the color of.
     */

  }, {
    key: "getRecordColor",
    value: function getRecordColor(recordOrRecordId) {
      var record = this._getRecord(recordOrRecordId);

      var recordColorMode = this._normalizedOpts.recordColorMode;

      switch (recordColorMode.type) {
        case _record_coloring.ModeTypes.NONE:
          return null;

        case _record_coloring.ModeTypes.BY_SELECT_FIELD:
          {
            if (recordColorMode.selectField.type !== _field.FieldType.SINGLE_SELECT) {
              return null;
            }

            var value = record.getCellValue(recordColorMode.selectField);
            return value && typeof value === 'object' && typeof value.color === 'string' ? (0, _private_utils.assertEnumValue)(_colors.default, value.color) : null;
          }

        case _record_coloring.ModeTypes.BY_VIEW:
          return this._recordStore.getViewDataStore(recordColorMode.view.id).getRecordColor(record);

        default:
          throw (0, _error_utils.spawnError)('Unknown record coloring mode: %s', (0, _private_utils.cast)(recordColorMode));
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_onChangeIsDataLoaded",
    value: function _onChangeIsDataLoaded() {
      this._onChange(WatchableRecordQueryResultKeys.isDataLoaded);
    }
    /**
     * Get notified of changes to the query result.
     *
     * Watchable keys are:
     * - `'records'`
     * - `'recordIds'`
     * - `'cellValues'`
     * - `'recordColors'`
     * - `'isDataLoaded'`
     * - `'cellValuesInField:' + someFieldId`
     *
     * Every call to `.watch` should have a matching call to `.unwatch`.
     *
     * Watching a key that needs to load data asynchronously will automatically
     * cause the data to be fetched. Once the data is available, the `callback`
     * will be called.
     *
     * Returns the array of keys that were watched.
     *
     * @param keys the keys to watch
     * @param callback a function to call when those keys change
     * @param context an optional context for `this` in `callback`.
     */

  }, {
    key: "watch",
    value: function watch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(RecordQueryResult.prototype), "watch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = validKeys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var key = _step2.value;

          if (key === WatchableRecordQueryResultKeys.recordColors) {
            this._watchRecordColorsIfNeeded();
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return validKeys;
    }
    /**
     * Unwatch keys watched with `.watch`.
     *
     * Should be called with the same arguments given to `.watch`.
     *
     * Unwatching a key that needs to load data asynchronously will automatically
     * cause the data to be unloaded.
     *
     * Returns the array of keys that were unwatched
     *
     * @param keys the keys to unwatch
     * @param callback the function passed to `.watch` for these keys
     * @param context the context that was passed to `.watch` for this `callback`
     */

  }, {
    key: "unwatch",
    value: function unwatch(keys, callback, context) {
      var validKeys = (0, _get2.default)((0, _getPrototypeOf2.default)(RecordQueryResult.prototype), "unwatch", this).call(this, keys, callback, context);
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = validKeys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var key = _step3.value;

          if (key === WatchableRecordQueryResultKeys.recordColors) {
            this._unwatchRecordColorsIfPossible();
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return validKeys;
    }
    /**
     * @internal
     */

  }, {
    key: "_watchRecordColorsIfNeeded",
    value: function _watchRecordColorsIfNeeded() {
      var watchCount = (this._changeWatchersByKey[WatchableRecordQueryResultKeys.recordColors] || []).length;

      if (!this._recordColorChangeHandler && watchCount >= 1) {
        this._watchRecordColors();
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_watchRecordColors",
    value: function _watchRecordColors() {
      var recordColorMode = this._normalizedOpts.recordColorMode;

      var handler = (model, key, recordIds) => {
        if (model === this) {
          this._onChange(WatchableRecordQueryResultKeys.recordColors, recordIds);
        } else {
          this._onChange(WatchableRecordQueryResultKeys.recordColors);
        }
      };

      switch (recordColorMode.type) {
        case _record_coloring.ModeTypes.NONE:
          break;

        case _record_coloring.ModeTypes.BY_SELECT_FIELD:
          this.watch("".concat(WatchableCellValuesInFieldKeyPrefix).concat(recordColorMode.selectField.id), handler);
          recordColorMode.selectField.watch('options', handler);
          break;

        case _record_coloring.ModeTypes.BY_VIEW:
          {
            this._recordStore.getViewDataStore(recordColorMode.view.id).watch('recordColors', handler);

            break;
          }

        default:
          throw (0, _error_utils.spawnError)('Unknown record coloring type %s', (0, _private_utils.cast)(recordColorMode));
      }

      this._recordColorChangeHandler = handler;
    }
    /**
     * @internal
     */

  }, {
    key: "_unwatchRecordColorsIfPossible",
    value: function _unwatchRecordColorsIfPossible() {
      var watchCount = (this._changeWatchersByKey[WatchableRecordQueryResultKeys.recordColors] || []).length;

      if (this._recordColorChangeHandler && watchCount === 0) {
        this._unwatchRecordColors();
      }
    }
    /**
     * @internal
     */

  }, {
    key: "_unwatchRecordColors",
    value: function _unwatchRecordColors() {
      var recordColorMode = this._normalizedOpts.recordColorMode;
      var handler = this._recordColorChangeHandler;
      (0, _error_utils.invariant)(handler, 'record color change handler must exist');

      switch (recordColorMode.type) {
        case _record_coloring.ModeTypes.NONE:
          break;

        case _record_coloring.ModeTypes.BY_SELECT_FIELD:
          this.unwatch("".concat(WatchableCellValuesInFieldKeyPrefix).concat(recordColorMode.selectField.id), handler);
          recordColorMode.selectField.unwatch('options', handler);
          break;

        case _record_coloring.ModeTypes.BY_VIEW:
          {
            this._recordStore.getViewDataStore(recordColorMode.view.id).unwatch('recordColors', handler);

            break;
          }

        default:
          throw (0, _error_utils.spawnError)('unknown record coloring type %s', (0, _private_utils.cast)(recordColorMode));
      }

      this._recordColorChangeHandler = null;
    }
    /**
     * @internal
     */

  }, {
    key: "_loadRecordColorsAsync",
    value: function _loadRecordColorsAsync() {
      var recordColorMode;
      return _regenerator.default.async(function _loadRecordColorsAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              recordColorMode = this._normalizedOpts.recordColorMode;
              _context.t0 = recordColorMode.type;
              _context.next = _context.t0 === _record_coloring.ModeTypes.NONE ? 4 : _context.t0 === _record_coloring.ModeTypes.BY_SELECT_FIELD ? 5 : _context.t0 === _record_coloring.ModeTypes.BY_VIEW ? 6 : 9;
              break;

            case 4:
              return _context.abrupt("return");

            case 5:
              return _context.abrupt("return");

            case 6:
              _context.next = 8;
              return _regenerator.default.awrap(this._recordStore.getViewDataStore(recordColorMode.view.id).loadDataAsync());

            case 8:
              return _context.abrupt("return");

            case 9:
              throw (0, _error_utils.spawnUnknownSwitchCaseError)('record color mode type', recordColorMode, 'type');

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * @internal
     */

  }, {
    key: "_unloadRecordColors",
    value: function _unloadRecordColors() {
      var recordColorMode = this._normalizedOpts.recordColorMode;

      switch (recordColorMode.type) {
        case _record_coloring.ModeTypes.NONE:
          return;

        case _record_coloring.ModeTypes.BY_SELECT_FIELD:
          // handled as part of fieldIdsOrNullIfAllFields
          return;

        case _record_coloring.ModeTypes.BY_VIEW:
          this._recordStore.getViewDataStore(recordColorMode.view.id).unloadData();

          break;

        default:
          throw (0, _error_utils.spawnUnknownSwitchCaseError)('record color mode type', recordColorMode, 'type');
      }
    }
  }, {
    key: "records",
    get: function get() {
      return this.recordIds.map(recordId => {
        var record = this._recordStore.getRecordByIdIfExists(recordId);

        (0, _error_utils.invariant)(record, 'Record missing in table');
        return record;
      });
    }
  }]);
  return RecordQueryResult;
}(_abstract_model_with_async_data.default);

(0, _defineProperty2.default)(RecordQueryResult, "_className", 'RecordQueryResult');
(0, _defineProperty2.default)(RecordQueryResult, "WatchableKeys", WatchableRecordQueryResultKeys);
(0, _defineProperty2.default)(RecordQueryResult, "WatchableCellValuesInFieldKeyPrefix", WatchableCellValuesInFieldKeyPrefix);
var _default = RecordQueryResult;
exports.default = _default;