"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.map");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.to-string");

require("core-js/modules/es.promise");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

require("regenerator-runtime/runtime");

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _mutations = require("../types/mutations");

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _get_sdk = _interopRequireDefault(require("../get_sdk"));

var _table = _interopRequireDefault(require("./table"));

var _record_store = _interopRequireDefault(require("./record_store"));

var _abstract_model = _interopRequireDefault(require("./abstract_model"));

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// How these model classes work:
//
// The single instance of the Base class maintains a reference to a plain JS
// object that contains all the data (baseData). All the other model classes
// receive a reference to baseData and traverse it to expose the data.
//
// As changes come in from liveapp, Base will apply them to the plain JS object.
// Since the other model classes have a reference to the same object, they'll
// always be accessing the most up-to-date values.
//
// Be careful not to return a reference to any non-primitive subtree of baseData,
// since the block developer could mutate it and we'll end up out of sync with
// liveapp.
var WatchableBaseKeys = Object.freeze({
  name: 'name',
  tables: 'tables',
  collaborators: 'collaborators',
  schema: 'schema'
});
/**
 * Any key in base that can be watched:
 * - `name`: the name of the base
 * - `tables`: the order of tables in the base
 * - `collaborators`: all the collaborators in the base
 * - `schema`: the base schema (essentially everything except for record data)
 */

/**
 * Model class representing a base.
 *
 * If you want the base model to automatically recalculate whenever the base schema changes, try the
 * {@link useBase} hook. Alternatively, you can manually subscribe to changes with
 * {@link useWatchable} (recommended) or [Base#watch](/api/models/Base#watch).
 *
 * @example
 * ```js
 * import {base} from '@airtable/blocks';
 *
 * console.log('The name of your base is', base.name);
 * ```
 * @docsPath models/Base
 */
var Base =
/*#__PURE__*/
function (_AbstractModel) {
  (0, _inherits2.default)(Base, _AbstractModel);
  (0, _createClass2.default)(Base, null, [{
    key: "_isWatchableKey",

    /** @internal */

    /** @internal */
    value: function _isWatchableKey(key) {
      return (0, _private_utils.isEnumValue)(WatchableBaseKeys, key);
    }
    /** @internal */

  }]);

  /**
   * @internal
   */
  function Base(baseData, airtableInterface) {
    var _this;

    (0, _classCallCheck2.default)(this, Base);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Base).call(this, baseData, baseData.id));
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_tableModelsById", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_tableRecordStoresByTableId", {});
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_airtableInterface", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "__billingPlanGrouping", void 0);
    (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_collaboratorIdsByNameAndEmail", null);
    _this._tableModelsById = {}; // Table instances are lazily created by getTableById.

    _this._airtableInterface = airtableInterface;
    _this.__billingPlanGrouping = baseData.billingPlanGrouping;
    return _this;
  }
  /**
   * @internal
   */


  (0, _createClass2.default)(Base, [{
    key: "getCollaboratorByIdIfExists",

    /**
     * The user matching the given ID, or `null` if that user does not exist or does not have access
     * to this base.
     *
     * @param collaboratorId The ID of the user.
     */
    value: function getCollaboratorByIdIfExists(collaboratorId) {
      var collaboratorsById = this._data.collaboratorsById;
      return (0, _private_utils.has)(collaboratorsById, collaboratorId) ? collaboratorsById[collaboratorId] : null;
    }
    /**
     * The user matching the given ID. Throws if that user does not exist
     * or does not have access to this base. Use {@link getCollaboratorByIdIfExists}
     * instead if you are unsure whether a collaborator with the given ID exists
     * and has access to this base.
     *
     * @param collaboratorId The ID of the user.
     */

  }, {
    key: "getCollaboratorById",
    value: function getCollaboratorById(collaboratorId) {
      var collaborator = this.getCollaboratorByIdIfExists(collaboratorId);

      if (!collaborator) {
        throw (0, _error_utils.spawnError)("No collaborator with ID %s has access to base '%s'", collaboratorId, this.name);
      }

      return collaborator;
    }
    /**
     * The user matching the given ID, name, or email address. Returns null if that user does not
     * exist or does not have access to this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getCollaboratorByIdIfExists} method instead.
     *
     * @param collaboratorIdOrNameOrEmail The ID of the user.
     */

  }, {
    key: "getCollaboratorIfExists",
    value: function getCollaboratorIfExists(idOrNameOrEmail) {
      var collaboratorById = this.getCollaboratorByIdIfExists(idOrNameOrEmail);

      if (collaboratorById) {
        return collaboratorById;
      }

      if (!this._collaboratorIdsByNameAndEmail) {
        this._collaboratorIdsByNameAndEmail = new Map();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = (0, _private_utils.entries)(this._data.collaboratorsById)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _step$value = (0, _slicedToArray2.default)(_step.value, 2),
                id = _step$value[0],
                _step$value$ = _step$value[1],
                email = _step$value$.email,
                name = _step$value$.name;

            this._collaboratorIdsByNameAndEmail.set(email, id); // we prevent `@` in names so theoretically we shouldn't encounter any collisions
            // between names and emails, but names themselves may not be unique. as we build the
            // name hash, we only add new values rather than overwrite existing ones. this means
            // that we'll prefer emails to names in the event of a collision.


            if (name && !this._collaboratorIdsByNameAndEmail.has(name)) {
              this._collaboratorIdsByNameAndEmail.set(name, id);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      var idForNameOrEmail = this._collaboratorIdsByNameAndEmail.get(idOrNameOrEmail);

      if (idForNameOrEmail !== undefined) {
        return this.getCollaboratorById(idForNameOrEmail);
      }

      return null;
    }
    /**
     * The user matching the given ID, name, or email address. Throws if that user does not exist
     * or does not have access to this base. Use {@link getCollaboratorIfExists} instead if you are
     * unsure whether a collaborator with the given ID exists and has access to this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getCollaboratorById} method instead.
     *
     * @param collaboratorIdOrNameOrEmail The ID of the user.
     */

  }, {
    key: "getCollaborator",
    value: function getCollaborator(idOrNameOrEmail) {
      var collaborator = this.getCollaboratorIfExists(idOrNameOrEmail);

      if (!collaborator) {
        throw (0, _error_utils.spawnError)("No collaborator with ID, name, or email of '%s' is in base '%s'", idOrNameOrEmail, this.name);
      }

      return collaborator;
    }
    /**
     * @internal
     */

  }, {
    key: "__getRecordStore",
    value: function __getRecordStore(tableId) {
      if ((0, _private_utils.has)(this._tableRecordStoresByTableId, tableId)) {
        return this._tableRecordStoresByTableId[tableId];
      }

      (0, _error_utils.invariant)(this._data.tablesById[tableId], 'table must exist');
      var newRecordStore = new _record_store.default(this._baseData, this._airtableInterface, tableId);
      this._tableRecordStoresByTableId[tableId] = newRecordStore;
      return newRecordStore;
    }
    /**
     * @internal
     */

  }, {
    key: "__getBaseData",
    value: function __getBaseData() {
      return this._data;
    }
    /**
     * The table matching the given ID, or `null` if that table does not exist in this base.
     *
     * @param tableId The ID of the table.
     */

  }, {
    key: "getTableByIdIfExists",
    value: function getTableByIdIfExists(tableId) {
      if (!this._data.tablesById[tableId]) {
        return null;
      } else {
        if (!this._tableModelsById[tableId]) {
          this._tableModelsById[tableId] = new _table.default(this._data, this, this.__getRecordStore(tableId), tableId, this._airtableInterface);
        }

        return this._tableModelsById[tableId];
      }
    }
    /**
     * The table matching the given ID. Throws if that table does not exist in this base. Use
     * {@link getTableByIdIfExists} instead if you are unsure whether a table exists with the given
     * ID.
     *
     * @param tableId The ID of the table.
     */

  }, {
    key: "getTableById",
    value: function getTableById(tableId) {
      var table = this.getTableByIdIfExists(tableId);

      if (!table) {
        throw (0, _error_utils.spawnError)("No table with ID %s in base '%s'", tableId, this.name);
      }

      return table;
    }
    /**
     * The table matching the given name, or `null` if no table exists with that name in this base.
     *
     * @param tableName The name of the table you're looking for.
     */

  }, {
    key: "getTableByNameIfExists",
    value: function getTableByNameIfExists(tableName) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = (0, _private_utils.entries)(this._data.tablesById)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _step2$value = (0, _slicedToArray2.default)(_step2.value, 2),
              tableId = _step2$value[0],
              tableData = _step2$value[1];

          if (tableData.name === tableName) {
            return this.getTableByIdIfExists(tableId);
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return null;
    }
    /**
     * The table matching the given name. Throws if no table exists with that name in this base. Use
     * {@link getTableByNameIfExists} instead if you are unsure whether a table exists with the
     * given name.
     *
     * @param tableName The name of the table you're looking for.
     */

  }, {
    key: "getTableByName",
    value: function getTableByName(tableName) {
      var table = this.getTableByNameIfExists(tableName);

      if (!table) {
        throw (0, _error_utils.spawnError)("No table named '%s' in base '%s'", tableName, this.name);
      }

      return table;
    }
    /**
     * The table matching the given ID or name. Returns `null` if no matching table exists within
     * this base.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getTableByIdIfExists} or
     * {@link getTableByNameIfExists} methods instead.
     *
     * @param tableIdOrName The ID or name of the table you're looking for.
     */

  }, {
    key: "getTableIfExists",
    value: function getTableIfExists(tableIdOrName) {
      var _this$getTableByIdIfE;

      return (_this$getTableByIdIfE = this.getTableByIdIfExists(tableIdOrName)) !== null && _this$getTableByIdIfE !== void 0 ? _this$getTableByIdIfE : this.getTableByNameIfExists(tableIdOrName);
    }
    /**
     * The table matching the given ID or name. Throws if no matching table exists within this base.
     * Use {@link getTableIfExists} instead if you are unsure whether a table exists with the given
     * name/ID.
     *
     * This method is convenient when building a block for a specific base, but for more generic
     * blocks the best practice is to use the {@link getTableById} or {@link getTableByName} methods
     * instead.
     *
     * @param tableIdOrName The ID or name of the table you're looking for.
     */

  }, {
    key: "getTable",
    value: function getTable(tableIdOrName) {
      var table = this.getTableIfExists(tableIdOrName);

      if (!table) {
        throw (0, _error_utils.spawnError)("No table with ID or name '%s' in base '%s'", tableIdOrName, this.name);
      }

      return table;
    }
    /**
     * _Beta feature with unstable API. May have breaking changes before release._
     *
     * Checks whether the current user has permission to create a table.
     *
     * Accepts partial input, in the same format as {@link unstable_createTableAsync}.
     *
     * Returns `{hasPermission: true}` if the current user can update the specified record,
     * `{hasPermission: false, reasonDisplayString: string}` otherwise. `reasonDisplayString` may be
     * used to display an error message to the user.
     *
     * @param name name for the table. must be case-insensitive unique
     * @param fields array of fields to create in the table
     *
     * @example
     * ```js
     * const createTableCheckResult = base.unstable_checkPermissionsForCreateTable();
     *
     * if (!createTableCheckResult.hasPermission) {
     *     alert(createTableCheckResult.reasonDisplayString);
     * }
     * ```
     */

  }, {
    key: "unstable_checkPermissionsForCreateTable",
    value: function unstable_checkPermissionsForCreateTable(name, fields) {
      return (0, _get_sdk.default)().__mutations.checkPermissionsForMutation({
        type: _mutations.MutationTypes.CREATE_SINGLE_TABLE,
        id: undefined,
        // Generated in createTableAsync.
        name: name,
        fields: fields === null || fields === void 0 ? void 0 : fields.map(field => {
          return {
            name: field.name,
            config: field.type ? _objectSpread({
              type: field.type
            }, field.options ? {
              options: field.options
            } : null) : undefined
          };
        })
      });
    }
    /**
     * _Beta feature with unstable API. May have breaking changes before release._
     *
     * An alias for `checkPermissionsForCreateTable(name, fields).hasPermission`.
     *
     * Checks whether the current user has permission to create a table.
     *
     * Accepts partial input, in the same format as {@link unstable_createTableAsync}.
     *
     * @param name name for the table. must be case-insensitive unique
     * @param fields array of fields to create in the table
     *
     * @example
     * ```js
     * const canCreateTable = table.unstable_hasPermissionToCreateTable();
     *
     * if (!canCreateTable) {
     *     alert('not allowed!');
     * }
     * ```
     */

  }, {
    key: "unstable_hasPermissionToCreateTable",
    value: function unstable_hasPermissionToCreateTable(name, fields) {
      return this.unstable_checkPermissionsForCreateTable(name, fields).hasPermission;
    }
    /**
     * _Beta feature with unstable API. May have breaking changes before release._
     *
     * Creates a new table.
     *
     * Throws an error if the user does not have permission to create a table, if an invalid
     * table name is provided, or if invalid fields are provided (invalid name, type or options).
     *
     * Refer to {@link FieldType} for supported field types, the write format for field options, and
     * other specifics for certain field types.
     *
     * At least one field must be specified. The first field in the `fields` array will be used as
     * the table's [primary field](https://support.airtable.com/hc/en-us/articles/202624179-The-Name-Field)
     * and must be a supported primary field type. Fields must have case-insensitive unique names
     * within the table.
     *
     * A default grid view will be created with all fields visible.
     *
     * This action is asynchronous. Unlike new records, new tables are **not** created
     * optimistically locally. You must `await` the returned promise before using the new
     * table in your block.
     *
     * @param name name for the table. must be case-insensitive unique
     * @param fields array of fields to create in the table: see below for details.
     *
     * @example
     * ```js
     * async function createNewTable() {
     *     const name = 'My new table';
     *     const fields = [
     *         // Name will be the primary field of the table.
     *         {name: 'Name', type: FieldType.SINGLE_LINE_TEXT},
     *         {name: 'Notes', type: FieldType.RICH_TEXT},
     *         {name: 'Attachments', type: FieldType.MULTIPLE_ATTACHMENTS},
     *         {name: 'Number', type: FieldType.NUMBER, options: {
     *             precision: 8,
     *         }},
     *         {name: 'Select', type: FieldType.SINGLE_SELECT, options: {
     *             choices: [
     *                 {name: 'A'},
     *                 {name: 'B'},
     *             ],
     *         }},
     *     ];
     *
     *     if (base.unstable_hasPermissionToCreateTable(name, fields)) {
     *         await base.unstable_createTableAsync(name, fields);
     *     }
     * }
     * ```
     */

  }, {
    key: "unstable_createTableAsync",
    value: function unstable_createTableAsync(name, fields) {
      var tableId;
      return _regenerator.default.async(function unstable_createTableAsync$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              tableId = this._airtableInterface.idGenerator.generateTableId();
              _context.next = 3;
              return _regenerator.default.awrap((0, _get_sdk.default)().__mutations.applyMutationAsync({
                id: tableId,
                type: _mutations.MutationTypes.CREATE_SINGLE_TABLE,
                name,
                fields: fields.map(field => {
                  return {
                    name: field.name,
                    config: _objectSpread({
                      type: field.type
                    }, field.options ? {
                      options: field.options
                    } : null)
                  };
                })
              }));

            case 3:
              return _context.abrupt("return", this.getTableById(tableId));

            case 4:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
    /**
     * @internal
     */

  }, {
    key: "__triggerOnChangeForChangedPaths",
    value: function __triggerOnChangeForChangedPaths(changedPaths) {
      var didSchemaChange = false;

      if (changedPaths.name) {
        this._onChange(WatchableBaseKeys.name);

        didSchemaChange = true;
      }

      if (changedPaths.tableOrder) {
        this._onChange(WatchableBaseKeys.tables);

        didSchemaChange = true; // Clean up deleted tables

        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = (0, _private_utils.entries)(this._tableModelsById)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _step3$value = (0, _slicedToArray2.default)(_step3.value, 2),
                tableId = _step3$value[0],
                tableModel = _step3$value[1];

            if (tableModel.isDeleted) {
              delete this._tableModelsById[tableId];
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }

      var tablesById = changedPaths.tablesById;

      if (tablesById) {
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = (0, _private_utils.entries)(tablesById)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _step4$value = (0, _slicedToArray2.default)(_step4.value, 2),
                _tableId = _step4$value[0],
                dirtyTablePaths = _step4$value[1];

            // Directly access from _tableModelsById to avoid creating
            // a table model if it doesn't already exist. If it doesn't exist,
            // nothing can be subscribed to any events on it.
            var table = this._tableModelsById[_tableId];

            if (table && dirtyTablePaths) {
              var didTableSchemaChange = table.__triggerOnChangeForDirtyPaths(dirtyTablePaths);

              if (didTableSchemaChange) {
                didSchemaChange = true;
              }
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }

      if (changedPaths.collaboratorsById || changedPaths.activeCollaboratorIds) {
        this._onChange(WatchableBaseKeys.collaborators);
      }

      if (changedPaths.appInterface) {
        didSchemaChange = true;
      }

      if (didSchemaChange) {
        this._onChange(WatchableBaseKeys.schema);
      }
    }
    /**
     * @internal
     */

  }, {
    key: "__applyChangesWithoutTriggeringEvents",
    value: function __applyChangesWithoutTriggeringEvents(changes) {
      // Internal method.
      // After applying all changes, changedPaths will have the same shape as
      // the subset of this._data that changed. For example, if some table's
      // name changes, changedPaths will be {tablesById: {tbl123: name: {_isDirty: true}}}.
      // Use it to call __triggerOnChangeForChangedPaths to trigger change events for
      // effected models
      var changedPaths = {};
      var _iteratorNormalCompletion5 = true;
      var _didIteratorError5 = false;
      var _iteratorError5 = undefined;

      try {
        for (var _iterator5 = changes[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
          var change = _step5.value;

          this._applyChange(change.path, change.value, changedPaths);
        }
      } catch (err) {
        _didIteratorError5 = true;
        _iteratorError5 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion5 && _iterator5.return != null) {
            _iterator5.return();
          }
        } finally {
          if (_didIteratorError5) {
            throw _iteratorError5;
          }
        }
      }

      return changedPaths;
    }
    /**
     * @internal
     */

  }, {
    key: "_applyChange",
    value: function _applyChange(path, value, changedPathsByRef) {
      var dataSubtree = this._data;
      var dirtySubtree = changedPathsByRef;

      for (var i = 0; i < path.length - 1; i++) {
        var part = path[i];

        if (!dataSubtree[part]) {
          // Certain fields are stored sparsely (e.g. cellValuesByFieldId),
          // so create an object on demand if needed.
          dataSubtree[part] = {};
        }

        dataSubtree = dataSubtree[part];

        if (!dirtySubtree[part]) {
          dirtySubtree[part] = {};
        }

        (0, _error_utils.invariant)(dirtySubtree[part], 'dirtySubtree');
        dirtySubtree = dirtySubtree[part];
      }

      var lastPathPart = path[path.length - 1];
      var didChange = !(0, _private_utils.isDeepEqual)(dataSubtree[lastPathPart], value);

      if (value === undefined) {
        delete dataSubtree[lastPathPart];
      } else {
        dataSubtree[lastPathPart] = value;
      }

      if (didChange) {
        if (!dirtySubtree[lastPathPart]) {
          dirtySubtree[lastPathPart] = {};
        }

        (0, _error_utils.invariant)(dirtySubtree[lastPathPart], 'dirtySubtree');
        dirtySubtree[lastPathPart]._isDirty = true;
      }
    }
  }, {
    key: "_dataOrNullIfDeleted",
    get: function get() {
      return this._baseData;
    }
    /**
     * The name of the base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log('The name of your base is', base.name);
     * ```
     */

  }, {
    key: "name",
    get: function get() {
      return this._data.name;
    }
    /**
     * The tables in this base. Can be watched to know when tables are created, deleted, or reordered in the base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log(`You have ${base.tables.length} tables`);
     * ```
     */

  }, {
    key: "tables",
    get: function get() {
      // TODO(kasra): cache and freeze this so it isn't O(n)
      var tables = [];

      this._data.tableOrder.forEach(tableId => {
        var table = this.getTableByIdIfExists(tableId); // NOTE: A table's ID may be in tableOrder without the table appearing
        // in tablesById, in which case getTableById will return null. This
        // happens if table was just created by the user, since we
        // wait for the push payload to deliver the table schema.

        if (table) {
          tables.push(table);
        }
      });

      return tables;
    }
    /**
     * The users who have access to this base.
     *
     * @example
     * ```js
     * import {base} from '@airtable/blocks';
     * console.log(base.activeCollaborators[0].email);
     * ```
     */

  }, {
    key: "activeCollaborators",
    get: function get() {
      return this._data.activeCollaboratorIds.map(collaboratorId => this.getCollaboratorById(collaboratorId));
    }
  }]);
  return Base;
}(_abstract_model.default);

(0, _defineProperty2.default)(Base, "_className", 'Base');
var _default = Base;
exports.default = _default;