"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

require("core-js/modules/es.symbol");

require("core-js/modules/es.symbol.description");

require("core-js/modules/es.array.filter");

require("core-js/modules/es.array.find");

require("core-js/modules/es.array.iterator");

require("core-js/modules/es.array.map");

require("core-js/modules/es.object.get-own-property-descriptors");

require("core-js/modules/es.object.to-string");

require("core-js/modules/web.dom-collections.for-each");

require("core-js/modules/web.dom-collections.iterator");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.RecordCard = exports.recordCardStylePropTypes = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn"));

var _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf"));

var _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized"));

var _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _emotion = require("emotion");

var React = _interopRequireWildcard(require("react"));

var _core = require("@styled-system/core");

var _get_sdk = _interopRequireDefault(require("../get_sdk"));

var _private_utils = require("../private_utils");

var _error_utils = require("../error_utils");

var _field3 = require("../types/field");

var _field4 = _interopRequireDefault(require("../models/field"));

var _record = _interopRequireDefault(require("../models/record"));

var _view = _interopRequireDefault(require("../models/view"));

var _color_utils = _interopRequireDefault(require("../color_utils"));

var _baymax_utils = require("./baymax_utils");

var _expand_record = _interopRequireDefault(require("./expand_record"));

var _box = _interopRequireDefault(require("./box"));

var _cell_renderer = _interopRequireDefault(require("./cell_renderer"));

var _use_watchable = _interopRequireDefault(require("./use_watchable"));

var _with_hooks = _interopRequireDefault(require("./with_hooks"));

var _use_view_metadata = _interopRequireDefault(require("./use_view_metadata"));

var _key_codes = require("./key_codes");

var _use_styled_system = _interopRequireDefault(require("./use_styled_system"));

var _system = require("./system");

var _with_styled_system = require("./with_styled_system");

var _tooltip_anchor_props = require("./types/tooltip_anchor_props");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2.default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// Mirrored from client_server_shared_config_settings
var FALLBACK_RECORD_NAME_FOR_DISPLAY = 'Unnamed record';
/**
 * Style props for the {@link RecordCard} component. Accepts:
 * * {@link FlexItemSetProps}
 * * {@link MarginProps}
 * * {@link PositionSetProps}
 *
 * @noInheritDoc
 */

var styleParser = (0, _core.compose)(_system.flexItemSet, _system.positionSet, _system.margin);

var recordCardStylePropTypes = _objectSpread({}, _system.flexItemSetPropTypes, {}, _system.positionSetPropTypes, {}, _system.marginPropTypes);

exports.recordCardStylePropTypes = recordCardStylePropTypes;
var CARD_PADDING = 12;
/** @hidden */

var CellValueAndFieldLabel = (_ref) => {
  var record = _ref.record,
      cellValue = _ref.cellValue,
      field = _ref.field,
      width = _ref.width,
      renderInvalidCellValue = _ref.renderInvalidCellValue;
  (0, _use_watchable.default)(field, ['name', 'type', 'options']);
  return React.createElement(_box.default, {
    style: {
      verticalAlign: 'top'
    },
    position: "relative",
    display: "inline-block",
    margin: 0,
    paddingRight: 2,
    width: width
  }, React.createElement(_box.default, {
    className: (0, _baymax_utils.baymax)('caps truncate'),
    fontSize: "11px",
    lineHeight: "13px",
    textColor: "#898989"
  }, field.name), React.createElement(_cell_renderer.default, {
    record: record,
    cellValue: cellValue,
    field: field,
    shouldWrap: false,
    cellClassName: "recordCardCellValue truncate",
    cellStyle: {
      lineHeight: '16px',
      fontSize: '12px'
    },
    renderInvalidCellValue: renderInvalidCellValue
  }));
};

CellValueAndFieldLabel.propTypes = {
  record: _propTypes.default.instanceOf(_record.default),
  // NOTE: this currently will not work for linked record fields, since CellRenderer
  // cannot currently handle all cell types.
  // TODO(jb): make the constraints for rendering cell values less strict than the
  // constraints we put on updating cell values.
  cellValue: _propTypes.default.any,
  field: _propTypes.default.instanceOf(_field4.default).isRequired,
  width: _propTypes.default.number.isRequired,
  renderInvalidCellValue: _propTypes.default.func
};
/**
 * Props for the {@link RecordCard} component. Also accepts:
 * * {@link RecordCardStyleProps}
 *
 * @noInheritDoc
 * @docsPath UI/components/RecordCard
 */

// TODO(jb): move this stuff into the field model when we decide on an api for it.
var FormulaicFieldTypes = {
  [_field3.FieldType.FORMULA]: true,
  [_field3.FieldType.ROLLUP]: true,
  [_field3.FieldType.MULTIPLE_LOOKUP_VALUES]: true
};

var isFieldFormulaic = field => {
  return (0, _private_utils.has)(FormulaicFieldTypes, field.type);
};

var getFieldResultType = field => {
  if (field.type === _field3.FieldType.COUNT) {
    return _field3.FieldType.NUMBER;
  }

  if (isFieldFormulaic(field)) {
    (0, _error_utils.invariant)(field.options, 'options');
    var result = field.options.result;

    if (typeof result === 'object' && result) {
      var resultType = result.type;
      (0, _error_utils.invariant)(typeof resultType === 'string', 'resultType must be string');
      return resultType;
    } else {
      // Formula is misconfigured.
      return _field3.FieldType.SINGLE_LINE_TEXT;
    }
  } else {
    return field.type;
  }
};
/**
 * @internal
 * Given a container size (ie, height of the record card), calculate the height and width of an
 * attachment thumbnail image to fit inside the square attachment preview. Left and top margin
 * are used to center non-square images.
 */


var calculateAttachmentDimensionsAndMargin = (attachment, containerSize) => {
  if (!attachment || !attachment.thumbnails || !attachment.thumbnails.large) {
    return {};
  }

  var _attachment$thumbnail = attachment.thumbnails.large,
      thumbWidth = _attachment$thumbnail.width,
      thumbHeight = _attachment$thumbnail.height;
  var height = Math.min(containerSize, thumbHeight);
  var width = Math.round(thumbWidth * height / thumbHeight);
  var marginTop = Math.round((containerSize - height) / 2);
  var marginLeft = Math.round((containerSize - width) / 2);
  return {
    height,
    width,
    marginTop,
    marginLeft
  };
};
/**
 * A card component that displays an Airtable record.
 *
 * [[ Story id="recordcard--example" title="RecordCard example" ]]
 *
 * @docsPath UI/components/RecordCard
 * @component
 */


var RecordCard =
/*#__PURE__*/
function (_React$Component) {
  (0, _inherits2.default)(RecordCard, _React$Component);

  /** @hidden */

  /** @hidden */

  /** @hidden */
  function RecordCard(props) {
    var _this;

    (0, _classCallCheck2.default)(this, RecordCard);
    _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(RecordCard).call(this, props));
    _this._onClick = _this._onClick.bind((0, _assertThisInitialized2.default)(_this));

    _this._validateProps(props);

    return _this;
  }
  /** @hidden */


  (0, _createClass2.default)(RecordCard, [{
    key: "UNSAFE_componentWillReceiveProps",
    value: function UNSAFE_componentWillReceiveProps(nextProps) {
      this._validateProps(nextProps);
    }
    /** @internal */

  }, {
    key: "_validateProps",
    value: function _validateProps(props) {
      var record = props.record,
          view = props.view,
          fields = props.fields,
          attachmentCoverField = props.attachmentCoverField;

      if (record && record instanceof _record.default && record.isDeleted) {
        throw (0, _error_utils.spawnError)('Record %s is deleted', record.id);
      }

      if (!record) {
        throw (0, _error_utils.spawnError)('Must provide record');
      }

      if (record && record instanceof _record.default && attachmentCoverField) {
        if (attachmentCoverField.parentTable.id !== record.parentTable.id) {
          throw (0, _error_utils.spawnError)('Attachment cover field %s must have the same parent table as record (record ID %s, table ID %s)', attachmentCoverField.id, record.id, record.parentTable.id);
        }
      }

      if (record && record instanceof _record.default && fields) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = fields[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _field = _step.value;

            if (!_field.isDeleted && _field.parentTable.id !== record.parentTable.id) {
              throw (0, _error_utils.spawnError)('Field %s must have the same parent table as record (record ID %s, table ID %s)', _field.id, record.id, record.parentTable.id);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      }

      if (record && record instanceof _record.default && view && !view.isDeleted) {
        if (view.parentTable.id !== record.parentTable.id) {
          throw (0, _error_utils.spawnError)('View %s must have the same parent table as record (record ID %s, table ID %s)', view.id, record.id, record.parentTable.id);
        }
      }
    }
    /** @internal */

  }, {
    key: "_onClick",
    value: function _onClick(e) {
      if (this.props.onClick) {
        this.props.onClick(e);
      } // Explicitly check if `hasOnClick` is false, which is only set by the Tooltip wrapper.
      // When wrapped in Tooltip, `onClick` will always exist because Tooltip supplies it. We use
      // `hasOnClick`, to account for whether the user defined their own `onClick`. We only want
      // to run this default expandRecord behavior if the user did not supply their own `onClick`.


      if (this.props.onClick === undefined || this.props.hasOnClick === false // TODO (stephen): remove tooltip anchor props
      ) {
          // NOTE: `null` disables the default click behavior.
          var record = this.props.record;
          var recordModel = record && record instanceof _record.default ? record : null;

          if (recordModel) {
            if ((0, _key_codes.isCommandModifierKeyEvent)(e) || e.shiftKey) {// No-op, let the <a> tag handle opening in new tab or window.
            } else {
              e.preventDefault();
              var opts = this.props.expandRecordOptions || {};
              (0, _expand_record.default)(recordModel, opts);
            }
          }
        }
    }
    /** @internal */

  }, {
    key: "_getAttachmentCover",
    value: function _getAttachmentCover(fieldsToUse) {
      var attachmentField = this._getAttachmentField(fieldsToUse);

      return attachmentField ? this._getFirstAttachmentInField(attachmentField) : null;
    }
    /** @internal */

  }, {
    key: "_getAttachmentField",
    value: function _getAttachmentField(fieldsToUse) {
      var attachmentCoverField = this.props.attachmentCoverField;

      if (attachmentCoverField && !attachmentCoverField.isDeleted && this._isAttachment(attachmentCoverField)) {
        return attachmentCoverField;
      } else if (attachmentCoverField === undefined) {
        // The attachment field in this case is either coming from the view
        // if there is a view, or from the table's arbitrary field ordering
        // if there is no view.
        // TODO: use the real cover field if the view is gallery or kanban instead of
        // the first attachment field
        var firstAttachmentFieldInView = fieldsToUse.find(field => {
          return this._isAttachment(field);
        });

        if (firstAttachmentFieldInView === undefined) {
          return null;
        }

        return firstAttachmentFieldInView;
      } else {
        return null;
      }
    }
    /** @internal */

  }, {
    key: "_isAttachment",
    value: function _isAttachment(field) {
      return getFieldResultType(field) === _field3.FieldType.MULTIPLE_ATTACHMENTS;
    }
    /** @internal */

  }, {
    key: "_getCellValue",
    value: function _getCellValue(field) {
      var record = this.props.record;

      if (record && record instanceof _record.default) {
        return record.getCellValue(field.id);
      } else {
        var _cellValue = record[field.id]; // To validate public cell values, we only have validateCellValueForUpdate
        // However, this is not implemented for computed fields (since you can't update them)
        // so we just skip the check.
        // TODO(emma): actually check this somehow.

        if (!field.isComputed) {
          var airtableInterface = (0, _get_sdk.default)().__airtableInterface;

          var appInterface = (0, _get_sdk.default)().__appInterface;

          var validationResult = airtableInterface.fieldTypeProvider.validateCellValueForUpdate(appInterface, _cellValue, null, field._data);

          if (!validationResult.isValid) {
            throw (0, _error_utils.spawnError)(validationResult.reason);
          }
        }

        return _cellValue;
      }
    }
    /** @internal */

  }, {
    key: "_getFirstAttachmentInField",
    value: function _getFirstAttachmentInField(attachmentField) {
      var attachmentsInField;

      if (attachmentField.type === _field3.FieldType.MULTIPLE_LOOKUP_VALUES) {
        var _cellValue2 = this._getCellValue(attachmentField);

        attachmentsInField = (0, _private_utils.flattenDeep)((0, _private_utils.values)(_cellValue2 ? _cellValue2.valuesByLinkedRecordId : {}));
      } else {
        attachmentsInField = this._getCellValue(attachmentField);
      }

      return attachmentsInField && attachmentsInField.length > 0 ? attachmentsInField[0] : null;
    }
    /** @internal */

  }, {
    key: "_getFields",
    value: function _getFields() {
      var _this$props = this.props,
          viewMetadata = _this$props.viewMetadata,
          fields = _this$props.fields,
          record = _this$props.record;
      var fieldsToUse;

      if (fields) {
        fieldsToUse = fields.filter(field => !field.isDeleted);
      } else if (viewMetadata && !viewMetadata.isDeleted) {
        fieldsToUse = viewMetadata.visibleFields;
      } else if (record && record instanceof _record.default && !record.isDeleted) {
        var parentTable = record.parentTable;
        fieldsToUse = parentTable.fields;
      } else {
        console.warn('RecordCard: no fields, view, or record, so rendering an empty card'); // eslint-disable-line no-console

        fieldsToUse = [];
      }

      return (0, _private_utils.uniqBy)(fieldsToUse, field => field.id);
    }
    /** @internal */

  }, {
    key: "_getPossibleFieldsForCard",
    value: function _getPossibleFieldsForCard() {
      var fields = this._getFields(); // remove primary field if it exists


      return fields.filter(field => {
        return !field.isPrimaryField;
      });
    }
    /** @internal */

  }, {
    key: "_getWidthAndFieldIdArray",
    value: function _getWidthAndFieldIdArray(cellContainerWidth, fieldsToUse) {
      var widthAndFieldIdArray = [];
      var runningWidth = 0;

      var airtableInterface = (0, _get_sdk.default)().__airtableInterface;

      var appInterface = (0, _get_sdk.default)().__appInterface;

      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = fieldsToUse[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _field2 = _step2.value;
          var uiConfig = airtableInterface.fieldTypeProvider.getUiConfig(appInterface, _field2._data);
          var desiredWidth = uiConfig.desiredCellWidthForRecordCard;

          if (runningWidth + desiredWidth < cellContainerWidth) {
            widthAndFieldIdArray.push({
              width: desiredWidth,
              fieldId: _field2.id
            });
            runningWidth += desiredWidth;
          } else {
            var minCellWidth = uiConfig.minimumCellWidthForRecordCard;

            if (runningWidth + minCellWidth < cellContainerWidth) {
              widthAndFieldIdArray.push({
                width: minCellWidth,
                fieldId: _field2.id
              });
              runningWidth += minCellWidth;
            } else {
              break;
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      if (runningWidth < cellContainerWidth && widthAndFieldIdArray.length > 0) {
        var lastWidthAndFieldId = widthAndFieldIdArray[widthAndFieldIdArray.length - 1];
        lastWidthAndFieldId.width += cellContainerWidth - runningWidth;
      }

      return widthAndFieldIdArray;
    }
    /** @internal */

  }, {
    key: "_getRecord",
    value: function _getRecord() {
      var record = this.props.record;

      if (record && record instanceof _record.default) {
        return record;
      } else {
        return null;
      }
    }
    /** @internal */

  }, {
    key: "_renderCellsAndFieldLabels",
    value: function _renderCellsAndFieldLabels(attachmentSize, fieldsToUse) {
      var _this$props2 = this.props,
          record = _this$props2.record,
          width = _this$props2.width,
          renderInvalidCellValue = _this$props2.renderInvalidCellValue;
      (0, _error_utils.invariant)(typeof width === 'number', 'width in defaultProps');
      var cellContainerWidth = width - CARD_PADDING - attachmentSize;

      var widthAndFieldIdArray = this._getWidthAndFieldIdArray(cellContainerWidth, fieldsToUse);

      var fieldsById = (0, _private_utils.keyBy)(fieldsToUse, o => o.id);
      return widthAndFieldIdArray.map(widthAndFieldId => {
        var field = fieldsById[widthAndFieldId.fieldId];
        return React.createElement(CellValueAndFieldLabel, (0, _extends2.default)({
          key: field.id,
          field: field,
          width: widthAndFieldId.width,
          renderInvalidCellValue: renderInvalidCellValue
        }, record instanceof _record.default ? {
          record
        } : {
          cellValue: record[field.id]
        }));
      });
    }
    /** @hidden */

  }, {
    key: "render",
    value: function render() {
      var _this$props3 = this.props,
          record = _this$props3.record,
          view = _this$props3.view,
          width = _this$props3.width,
          height = _this$props3.height,
          onClick = _this$props3.onClick,
          onMouseEnter = _this$props3.onMouseEnter,
          onMouseLeave = _this$props3.onMouseLeave,
          className = _this$props3.className,
          style = _this$props3.style;

      if (record && record instanceof _record.default && record.isDeleted) {
        return null;
      }

      var allFields = this._getFields();

      var fieldsToUse = this._getPossibleFieldsForCard();

      var attachmentObjIfAvailable = this._getAttachmentCover(fieldsToUse);

      var hasAttachment = !!attachmentObjIfAvailable;
      var hasOnClick = !!onClick || !!this._getRecord();
      var containerClasses = (0, _emotion.cx)((0, _baymax_utils.baymax)('white rounded relative block overflow-hidden'), {
        [(0, _baymax_utils.baymax)('pointer cardBoxShadow')]: hasOnClick,
        [(0, _baymax_utils.baymax)('stroked1')]: !hasOnClick
      }, className); // use height as size in order to get square attachment

      (0, _error_utils.invariant)(typeof height === 'number', 'height in defaultProps');
      var attachmentSize = hasAttachment ? height : 0;
      var primaryValue;
      var isUnnamed;
      var recordName;
      var recordUrl;
      var recordColor;

      if (record instanceof _record.default) {
        recordUrl = record.url;
        recordName = record.name;

        if (view) {
          recordColor = record.getColorInView(view);
        }
      } else {
        var primaryField = allFields.length > 0 ? allFields[0].parentTable.primaryField : null;
        var primaryCellValue = primaryField ? record[primaryField.id] : null;
        recordName = primaryCellValue === null || primaryCellValue === undefined ? null : String(primaryCellValue);
      }

      if ((0, _private_utils.isNullOrUndefinedOrEmpty)(recordName)) {
        primaryValue = FALLBACK_RECORD_NAME_FOR_DISPLAY;
        isUnnamed = true;
      } else {
        primaryValue = recordName;
        isUnnamed = false;
      }

      var attachmentDimensionsAndPosition = calculateAttachmentDimensionsAndMargin(attachmentObjIfAvailable, attachmentSize);
      return React.createElement("a", {
        href: onClick === undefined && recordUrl ? recordUrl : undefined,
        className: containerClasses,
        style: _objectSpread({}, style, {
          width,
          height
        }),
        onClick: this._onClick,
        onMouseEnter: onMouseEnter || undefined,
        onMouseLeave: onMouseLeave || undefined
      }, React.createElement(_box.default, {
        right: "".concat(attachmentSize, "px"),
        backgroundColor: "transparent",
        padding: "".concat(CARD_PADDING, "px"),
        position: "absolute",
        top: 0,
        bottom: 0,
        left: 0,
        textColor: "dark"
      }, React.createElement(_box.default, {
        className: (0, _emotion.cx)({
          unnamed: isUnnamed
        }),
        fontWeight: 500,
        position: "relative",
        marginTop: 0,
        display: "flex",
        alignItems: "center",
        lineHeight: 1.5,
        height: "18px",
        fontSize: "14px"
      }, recordColor && React.createElement(_box.default, {
        width: "6px",
        height: "20px",
        flex: "none",
        marginRight: 1,
        borderRadius: "circle",
        backgroundColor: _color_utils.default.getHexForColor(recordColor)
      }), React.createElement(_box.default, {
        className: (0, _baymax_utils.baymax)('truncate'),
        flex: "auto"
      }, primaryValue)), React.createElement(_box.default, {
        textColor: "#555555",
        position: "absolute",
        marginTop: "3px"
      }, this._renderCellsAndFieldLabels(attachmentSize, fieldsToUse))), attachmentObjIfAvailable && attachmentObjIfAvailable.thumbnails && attachmentObjIfAvailable.thumbnails.large && React.createElement(_box.default, {
        className: (0, _baymax_utils.baymax)('noevents'),
        style: {
          borderTopRightRadius: 2,
          borderBottomRightRadius: 2
        },
        height: "".concat(attachmentSize, "px"),
        width: "".concat(attachmentSize, "px"),
        position: "absolute",
        right: "0",
        overflow: "hidden"
      }, React.createElement("img", {
        draggable: false,
        height: attachmentDimensionsAndPosition.height,
        width: attachmentDimensionsAndPosition.width,
        style: {
          marginTop: attachmentDimensionsAndPosition.marginTop,
          marginLeft: attachmentDimensionsAndPosition.marginLeft
        },
        src: attachmentObjIfAvailable.thumbnails.large.url
      })));
    }
  }]);
  return RecordCard;
}(React.Component);

exports.RecordCard = RecordCard;
(0, _defineProperty2.default)(RecordCard, "propTypes", _objectSpread({
  // Record can either be a record model or a record def (cellValuesByFieldId)
  record: _propTypes.default.oneOfType([_propTypes.default.instanceOf(_record.default), _propTypes.default.object]),
  // Should provide one of fields and view
  fields: _propTypes.default.arrayOf(_propTypes.default.instanceOf(_field4.default).isRequired),
  view: _propTypes.default.instanceOf(_view.default),
  // This component will always respect attachmentCoverField if one is passed in.
  // Pass a null value to explicitly indicate that an attachment should not be
  // shown. If attachmentCoverField is undefined, it will fall back to using the
  // first attachment in the view provided (if a view is provided).
  attachmentCoverField: _propTypes.default.instanceOf(_field4.default),
  width: _propTypes.default.number,
  height: _propTypes.default.number,
  onClick: _propTypes.default.func,
  hasOnClick: _propTypes.default.bool,
  onMouseEnter: _propTypes.default.func,
  onMouseLeave: _propTypes.default.func,
  // TODO: add all other mouse events: https://facebook.github.io/react/docs/events.html#mouse-events
  className: _propTypes.default.string,
  style: _propTypes.default.object,
  expandRecordOptions: _propTypes.default.object,
  renderInvalidCellValue: _propTypes.default.func
}, _tooltip_anchor_props.tooltipAnchorPropTypes, {}, recordCardStylePropTypes));
(0, _defineProperty2.default)(RecordCard, "defaultProps", {
  width: 568,
  height: 80,
  className: '',
  style: {}
});

var _default = (0, _with_hooks.default)(RecordCard, props => {
  var _splitStyleProps = (0, _with_styled_system.splitStyleProps)(props, styleParser.propNames),
      styleProps = _splitStyleProps.styleProps,
      nonStyleProps = _splitStyleProps.nonStyleProps;

  var record = nonStyleProps.record,
      fields = nonStyleProps.fields,
      view = nonStyleProps.view,
      className = nonStyleProps.className;
  var classNameForStyledProps = (0, _use_styled_system.default)(styleProps, styleParser);
  var recordModel = record && record instanceof _record.default ? record : null;
  var parentTable = null;

  if (recordModel) {
    parentTable = recordModel.parentTable;
  } else if (fields && fields.length > 0) {
    parentTable = fields[0].parentTable;
  } else if (view) {
    parentTable = view.parentTable;
  }

  (0, _use_watchable.default)(recordModel, ['name', view ? "colorInView:".concat(view.id) : null]); // It's safe to watch the record's parentTable since a record's parent table never changes.

  (0, _use_watchable.default)(parentTable, ['fields']); // if a view is supplied, we need to load the field order to use it for rendering the card

  var viewMetadata = (0, _use_view_metadata.default)(view);
  return {
    viewMetadata,
    className: (0, _emotion.cx)(classNameForStyledProps, className)
  };
});

exports.default = _default;